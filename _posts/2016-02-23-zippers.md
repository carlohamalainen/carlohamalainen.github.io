---
id: 691
title: Zippers
date: 2016-02-23T00:00:00+00:00
author: Carlo Hamalainen
layout: post
guid: http://carlo-hamalainen.net/2016/02/23/zippers/
permalink: /2016/02/23/zippers/
restapi_import_id:
  - 596a05ef0330b
original_post_id:
  - "16"
categories:
  - Uncategorized
format: image
---
This note about zippers follows [Backtracking Iterators (Jean-Christophe Filliâtre)](https://www.lri.fr/~filliatr/publis/enum2.pdf). The paper has examples in OCaml but they translate to Haskell fairly directly. Literate Haskell source for this post is here: <https://github.com/carlohamalainen/playground/tree/master/haskell/zipper>. To run this file, first install QuickCheck: 

<pre>cabal update
cabal install QuickCheck
</pre>

<pre>&gt; module Zipper where
&gt;
&gt; import Debug.Trace
&gt; import Test.QuickCheck
&gt; import Test.QuickCheck.Gen
</pre>

### A tree datatype 

For our examples, we use a simple algebraic datatype, a balanced binary tree with integer labels for the nodes: 

<pre>&gt; data Tree = Empty | Node Tree Int Tree
&gt;           deriving (Eq, Show)
</pre>

Here is an example tree: 

<pre>&gt; tree :: Tree
&gt; tree = Node
&gt;          (Node Empty 1 Empty)
&gt;          2
&gt;          (Node Empty 3 (Node Empty 4 Empty))
</pre>

We would normally draw this tree like this, with E for Empty: 

<pre>2
     / 
    /   
   1     3
  /    / 
 E   E E   4
          / 
         E   E
</pre>

Think about traversing the tree. At the beginning there is no path &#8211; we are at the top of the tree. Otherwise we have gone down the left subtree or the right subtree. 

If we went down the left branch at a node, we would have at hand the path that we followed to get to this node, the value at the node (an integer), and the tree on the right subtree that we did not visit.

Start at the top of the tree: 

<pre>path: Top (haven't gone anywhere)

tree:
      2
     / 
    /   
   1     3
  /    / 
 E   E E   4
          / 
         E   E
</pre>

Now walk down the left branch. 

<pre>path: went left, have a 2, and the subtree
      to the right of us is
                                 3
                                / 
                               E   4
                                  / 
                                 E   E

we are focused on this subtree:

   1
  / 
 E   E

</pre>

Encode this information in a type: 

<pre>&gt; data Path = Top                      -- ^ No path.
&gt;           | WentLeft  Path Int Tree  -- ^ Followed the left subtree
&gt;           | WentRight Tree Int Path  -- ^ Followed the right subtree
&gt;           deriving (Eq, Show)
</pre>

A zipper is a tree with a path. 

<pre>&gt; data Zipper = Zipper Tree Path
&gt;             deriving (Eq, Show)
</pre>

### Working with zippers 

The initial zipper is just the tree with no path. 

<pre>&gt; createZipper :: Tree -&gt; Zipper
&gt; createZipper t = Zipper t Top
</pre>

Conversely, if we have a zipper and we are at the top, we can get the tree out of it. 

<pre>&gt; unZipper :: Zipper -&gt; Tree
&gt; unZipper (Zipper t Top) = t
&gt; unZipper (Zipper t p)   = error $ "Can't unZipper here, path is " ++ show p ++ " with tree " ++ show t
</pre>

Intuitively, we would expect that unZipper . createZipper = id, and we can check this using [QuickCheck](https://hackage.haskell.org/package/QuickCheck-2.8.2/docs/Test-QuickCheck.html). First, provide an instance of Arbitrary for our binary trees: 

<pre>&gt; instance Arbitrary Tree where
&gt;   arbitrary = frequency [ (1, return Empty) -- Empty
&gt;                         , (1, arbNode)      -- Node   
&gt;                         ]
&gt;       where arbNode = do l &lt;- arbitrary   -- 
&gt;                          n &lt;- arbitrary   -- 
&gt;                          r &lt;- arbitrary   -- 
&gt;                          return $ Node l n r
</pre>

Now the property unZipper . createZipper = id can be written as: 

<pre>&gt; prop_finish_createZipper t = unZipper (createZipper t) == t
</pre>

Check it: 

<pre>*Zipper&gt; quickCheck prop_finish_create
+++ OK, passed 100 tests.
</pre>

Looks good. Use verboseCheck prop\_finish\_create to see the values being generated. 

Back to the zipper. Walking into the left subtree, as in the example above, involves moving the focus to the left subtree, and noting the node and the right subtree in the path component.

<pre>&gt; goDownLeft :: Zipper -&gt; Zipper
&gt; goDownLeft (Zipper Empty        _) = error "Can't go down-left on an empty tree."
&gt; goDownLeft (Zipper (Node l x r) p) = Zipper l (WentLeft p x r)
</pre>

Going down the right subtree is similar: 

<pre>&gt; goDownRight :: Zipper -&gt; Zipper
&gt; goDownRight (Zipper Empty        _) = error "Can't go down-right on an empty tree."
&gt; goDownRight (Zipper (Node l x r) p) = Zipper r (WentRight l x p)
</pre>

Going up is the inverse of goDownLeft and goDownRight. 

<pre>&gt; goUp :: Zipper -&gt; Zipper
&gt; goUp (Zipper Empty Top)           = Zipper Empty Top
&gt; goUp (Zipper l (WentLeft  p x r)) = Zipper (Node l x r) p
&gt; goUp (Zipper r (WentRight l x p)) = Zipper (Node l x r) p
</pre>

And we might want to go all the way up: 

<pre>&gt; unzipZipper :: Zipper -&gt; Tree
&gt; unzipZipper (Zipper t Top) = t
&gt; unzipZipper z              = unzipZipper $ goUp z
</pre>

Now we’d like to check with QuickCheck that going down an arbitrary path through a tree, then going all the way back up should bring us back to the same tree. So we will have to create random trees, paired with random paths through those trees. A tuple of type (Tree, Zipper) could work, but runs into dramas with overlapping instances since QuickCheck provides an instance for types, namely Arbitrary (a, b).

As a work-around, make a data type that holds a tree and a zipper:

<pre>&gt; data TreeAndZipper = TreeAndZipper Tree Zipper
&gt;   deriving (Eq, Show)
</pre>

Here is the instance of Arbitrary: 

<pre>&gt; instance Arbitrary TreeAndZipper where
&gt;   arbitrary = do t                   p                   return $ TreeAndZipper t p
&gt;
&gt;     where
&gt;         arbPath z@(Zipper t p) = frequency [ (1, return z)    -- stop here
&gt;                                            , (1, arbPath' z)  -- continue downwards
&gt;                                            ]
&gt;
&gt;         arbPath' z@(Zipper Empty _) = return z
&gt;         arbPath' z                  = frequency [ (1, arbPath $ goDownLeft  z)    -- go down left
&gt;                                                 , (1, arbPath $ goDownRight z)    -- go down right
&gt;                                                 , (1, return z)                   -- stop
&gt;                                                 ]
</pre>

Now with this instance we can encode the test that going down in a tree and then back up brings us back to the same tree.

<pre>&gt; prop_zip_unzip :: TreeAndZipper -&gt; Bool
&gt; prop_zip_unzip (TreeAndZipper t z) = t == unzipZipper z
</pre>

Check it: 

<pre>*Zipper&gt; quickCheck prop_zip_unzip
+++ OK, passed 100 tests.
</pre>

Using verboseCheck we can see some of the values. Here is a sample:

<pre>(lots of output...)

TreeAndZipper (Node (Node (Node (Node (Node (Node (Node Empty (-7) (Node (Node (Node (Node Empty 88 (Node Empty (-79) Empty)) 82 (Node (Node Empty (-20) Empty) (-15) (Node Empty (-94) Empty))) (-60) Empty) 55 (Node Empty 0 Empty))) 6 (Node Empty (-7) Empty)) (-18) (Node Empty (-80) (Node Empty 60 Empty))) (-35) (Node Empty (-73) Empty)) (-32) (Node (Node (Node (Node (Node Empty (-71) Empty) 30 (Node (Node Empty 0 Empty) (-68) (Node Empty 91 Empty))) 1 (Node Empty (-46) (Node Empty (-41) (Node (Node Empty 93 Empty) 79 (Node (Node Empty 48 (Node (Node Empty 46 Empty) 76 (Node (Node Empty (-57) (Node Empty 90 Empty)) 34 (Node Empty (-11) (Node Empty (-10) Empty))))) 55 (Node Empty 65 (Node (Node (Node (Node Empty 2 (Node Empty 11 (Node Empty 34 Empty))) (-69) Empty) 68 Empty) 49 (Node Empty (-67) (Node (Node Empty 73 (Node Empty 59 (Node (Node Empty (-28) Empty) (-22) Empty))) (-15) Empty))))))))) 39 (Node Empty 40 (Node (Node (Node (Node Empty 88 Empty) 60 Empty) (-87) Empty) 53 Empty))) (-43) (Node Empty (-16) Empty))) 54 (Node Empty 73 Empty)) (-31) Empty) (Zipper (Node (Node (Node (Node (Node (Node Empty (-7) (Node (Node (Node (Node Empty 88 (Node Empty (-79) Empty)) 82 (Node (Node Empty (-20) Empty) (-15) (Node Empty (-94) Empty))) (-60) Empty) 55 (Node Empty 0 Empty))) 6 (Node Empty (-7) Empty)) (-18) (Node Empty (-80) (Node Empty 60 Empty))) (-35) (Node Empty (-73) Empty)) (-32) (Node (Node (Node (Node (Node Empty (-71) Empty) 30 (Node (Node Empty 0 Empty) (-68) (Node Empty 91 Empty))) 1 (Node Empty (-46) (Node Empty (-41) (Node (Node Empty 93 Empty) 79 (Node (Node Empty 48 (Node (Node Empty 46 Empty) 76 (Node (Node Empty (-57) (Node Empty 90 Empty)) 34 (Node Empty (-11) (Node Empty (-10) Empty))))) 55 (Node Empty 65 (Node (Node (Node (Node Empty 2 (Node Empty 11 (Node Empty 34 Empty))) (-69) Empty) 68 Empty) 49 (Node Empty (-67) (Node (Node Empty 73 (Node Empty 59 (Node (Node Empty (-28) Empty) (-22) Empty))) (-15) Empty))))))))) 39 (Node Empty 40 (Node (Node (Node (Node Empty 88 Empty) 60 Empty) (-87) Empty) 53 Empty))) (-43) (Node Empty (-16) Empty))) 54 (Node Empty 73 Empty)) (WentLeft Top (-31) Empty))
Passed:
TreeAndZipper (Node Empty (-33) Empty) (Zipper (Node Empty (-33) Empty) Top)
Passed:
TreeAndZipper Empty (Zipper Empty Top)
Passed:
TreeAndZipper (Node Empty (-95) Empty) (Zipper (Node Empty (-95) Empty) Top)
+++ OK, passed 100 tests.
</pre>

### Traversals with a zipper 

A nifty thing about zippers is that we can use them to step through a traversal, controlling the process programatically. If we are walking through a tree, we might be finished, or we have produced a value (an Int) but need to keep going through the zipper:

<pre>&gt; data Step = Finished
&gt;           | KeepGoing Int Zipper
&gt;           deriving Show
</pre>

The step function converts a zipper into this state (step) type: 

<pre>&gt; step :: Zipper -&gt; Step
</pre>

If we have an empty tree and no path, we are done.

<pre>&gt; step (Zipper Empty Top) = Finished
</pre>

If we have gone down-left, make note of the node’s value x and the rest of the zipper: 

<pre>&gt; step (Zipper Empty (WentLeft  p x r)) = KeepGoing x (Zipper r p)
</pre>

Otherwise, we have a tree and a path, so try to continue by going down-left: 

<pre>&gt; step (Zipper t p) = step $ goDownLeft (Zipper t p)
</pre>

In summary: 

<pre>&gt; step :: Zipper -&gt; Step
&gt; step (Zipper Empty Top)               = Finished
&gt; step (Zipper Empty (WentLeft  p x r)) = KeepGoing x (Zipper r p)
&gt; step (Zipper t p)                     = step $ goDownLeft (Zipper t p)
</pre>

By repeatedly applying step we get an inorder traversal of the tree: 

<pre>&gt; inorder :: Tree -&gt; [Int]
&gt; inorder t = runStep (step (Zipper t Top)) []
&gt;   where
&gt;     runStep :: Step -&gt; [Int] -&gt; [Int]
&gt;     runStep Finished                    acc = acc
&gt;     runStep (KeepGoing x (Zipper t' p)) acc = runStep (step (Zipper t' p)) (acc ++ [x])
</pre>

(As an aside, runStep is tail recursive.) 

Using inorder on our example tree: 

<pre>*Zipper&gt; inorder tree
[1,2,3,4]
</pre>

Here is a plain recursive definition of an inorder traversal: 

<pre>&gt; inorder' :: Tree -&gt; [Int]
&gt; inorder' Empty = []
&gt; inorder' (Node l x r) = inorder' l ++ [x] ++ inorder' r
</pre>

We can use this to verify that our fancy zipper inorder traversal is correct: 

<pre>&gt; prop_inorder :: Tree -&gt; Bool
&gt; prop_inorder t = inorder t == inorder' t
</pre>

Testing it: 

<pre>*Zipper&gt; quickCheck prop_inorder
+++ OK, passed 100 tests.
</pre>

If we want to do something different in the traversal, for example running a monadic action, we can use the same Step datatype and change the definition of runStep: 

<pre>&gt; inorderM :: Monad m =&gt; (Int -&gt; m a) -&gt; Tree -&gt; m ()
&gt; inorderM a t = runStepM a $ step (Zipper t Top)
&gt;   where
&gt;     runStepM :: Monad m =&gt; (Int -&gt; m a) -&gt; Step -&gt; m ()
&gt;     runStepM _ Finished                    = return ()
&gt;     runStepM a (KeepGoing x (Zipper t' p)) = (a x) &gt;&gt; (runStepM a $ step (Zipper t' p))
</pre>

Example usage: 

<pre>*Zipper&gt; inorderM (x -&gt; putStrLn $ "Node value: " ++ show x) tree
Node value: 1
Node value: 2
Node value: 3
Node value: 4
</pre>

### Mapping over a tree 

If we want to apply a function to each value in a tree, a recursive definition might be: 

<pre>&gt; mapTree :: (Int -&gt; Int) -&gt; Tree -&gt; Tree
&gt; mapTree _ Empty = Empty
&gt; mapTree f (Node l x r) = Node (mapTree f l) (f x) (mapTree f r)
</pre>

<pre>*Zipper&gt; tree
Node (Node Empty 1 Empty) 2 (Node Empty 3 (Node Empty 4 Empty))

*Zipper&gt; mapTree (+1) tree
Node (Node Empty 2 Empty) 3 (Node Empty 4 (Node Empty 5 Empty))
</pre>

We can check that mapTree id == mapTree: 

<pre>&gt; prop_maptree :: Tree -&gt; Bool
&gt; prop_maptree t = t == (mapTree id t)
</pre>

<pre>*Zipper&gt; quickCheck prop_maptree
+++ OK, passed 100 tests.
</pre>

We can also use a zipper to map over the tree by using a different data type to represent the stepping: 

<pre>&gt; data MapStep = MapFinished
&gt;              | MoreL Int Zipper
&gt;              | More2 Zipper Int Zipper
&gt;              deriving Show
</pre>

<pre>&gt; stepMap :: (Int -&gt; Int) -&gt; Zipper -&gt; MapStep
&gt; stepMap _ (Zipper Empty Top              ) = MapFinished
&gt; stepMap f (Zipper Empty (WentLeft  p x r)) = MoreL (f x) (Zipper r p)
&gt; stepMap f (Zipper (Node l x r) p)          = More2 (Zipper l p) (f x) (Zipper r p)
</pre>

<pre>&gt; mapTree' :: (Int -&gt; Int) -&gt; Tree -&gt; Tree
&gt; mapTree' f t = runStep (stepMap f $ Zipper t Top)
&gt;   where
&gt;     runStep :: MapStep -&gt; Tree
&gt;     runStep MapFinished     = Empty
&gt;     runStep (MoreL x z)     = Node Empty x (runStep $ stepMap f z)
&gt;     runStep (More2 zl x zr) = Node (runStep $ stepMap f zl) x (runStep $ stepMap f zr)
</pre>

Testing it: 

<pre>*Zipper&gt; tree
Node (Node Empty 1 Empty) 2 (Node Empty 3 (Node Empty 4 Empty))

*Zipper&gt; mapTree' (+1) tree
Node (Node Empty 2 Empty) 3 (Node Empty 4 (Node Empty 5 Empty))
</pre>

And testing it using QuickCheck: 

<pre>&gt; prop_maptree' :: Tree -&gt; Bool
&gt; prop_maptree' t = (mapTree (+1) t) == (mapTree' (+1) t)
</pre>

<pre>*Zipper&gt; quickCheck prop_maptree'
+++ OK, passed 100 tests.
</pre>

The Main.hs file runs all the tests: 

<pre>$ ghc --make Main.hs
[1 of 2] Compiling Zipper           ( Zipper.lhs, Zipper.o )
[2 of 2] Compiling Main             ( Main.hs, Main.o )
Linking Main ...

$ ./Main
prop_finish_createZipper
+++ OK, passed 100 tests.
prop_inorder
+++ OK, passed 100 tests.
prop_maptree
+++ OK, passed 100 tests.
prop_maptree'
+++ OK, passed 100 tests.
prop_zip_unzip
+++ OK, passed 100 tests.
</pre>