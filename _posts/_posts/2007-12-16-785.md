---
id: 785
date: 2007-12-16T00:00:00+00:00
author: Carlo Hamalainen
layout: post
guid: http://carlo-hamalainen.net/2007/12/16/
permalink: /2007/12/16/785/
restapi_import_id:
  - 596a05ef0330b
original_post_id:
  - "16"
categories:
  - Uncategorized
format: image
---
Using &#8216;yield&#8217; to simulate a Markov chain

One thing that I really like about Sage is that it uses Python as its underlying language. This means that we get &#8220;for free&#8221; many nice features of Python. One of these features that I particularly like is the <tt>yield</tt> keyword. Here is a small example:

<pre>def foo():
    i = 0
    while True:
        yield i
        i = i + 1
</pre>

We can use the <tt>foo</tt> function as a _generator_:

<pre>sage: g = foo()
sage: print g.next()
0
sage: print g.next()
1
sage: print g.next()
2
</pre>

In other words, the <tt>yield</tt> keyword acts as a way to a Python function into a generator. The execution of <tt>foo</tt> is paused until the next call to <tt>g.next()</tt>. If we reach the end of the function, the <tt>StopIteration</tt> exception is raised.

The <tt>yield</tt> keyword makes it pretty easy to write the skeleton for a Markov chain simulator, using the following basic form:

<pre>def markov_chain():
    state = initial_state()
    while True:
        yield state

        state = new_state(state)

        if some_condition: return
</pre>

For a real example, see the latin\_square\_generator function in [latin.sage](http://carlo-hamalainen.net/sage/latin-1.0/latin.sage) which is part of a small library for [latin square manipulations in Sage](http://carlo-hamalainen.net/sage/latin-1.0/). The Markov chain itself was given by Jacobson and Matthews in &#8220;Generating uniformly distributed random Latin squares,&#8221; Journal of Combinatorial Designs, vol 4, 1996, no 6, pp 405&#8211;437.